# -*- coding: utf-8 -*-
"""Automated Energy Meter Reading (AMR) using Image Processing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UnAISOnADtchfrl9l776KROOgUrlHbhq

Install pytesseract OCR
"""

!pip install pytesseract

"""Install easyocr"""

!pip install easyocr

"""Download detection and recognition model of easyocr"""

reader=easyocr.Reader(['en'])

"""Import required libraries"""

import numpy as np
import cv2
from PIL import Image
import pytesseract
from google.colab.patches import cv2_imshow
import imutils
pytesseract.pytesseract.tesseract_cmd = r'/usr/local/bin/pytesseract'
import matplotlib.pyplot as plt
import easyocr

"""Reading Meter Image"""

img_meter_o = cv2.imread("example.png")
 cv2_imshow(img_meter_o)

"""Convert meter image from BGR TO HSV"""

img_meter = cv2.cvtColor(img_meter_o, cv2.COLOR_BGR2HSV)
cv2_imshow(img_meter)

"""Create mask to get approx Region of Interest"""

roi_lower = np.array([40, 25, 0])
 roi_upper = np.array( [80, 255, 255])
 mask = cv2.inRange(img_meter, roi_lower, roi_upper)
 cv2_imshow(mask)

"""Perform Bitwise_AND of mask image and original image to get ROI"""

img_meter = cv2.bitwise_and(img_meter_o,img_meter_o, mask= mask)
cv2_imshow(img_meter)

"""Extract Region of Interest by finding contours"""

contours, hierarchy = cv2.findContours(mask, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
contours = sorted(contours, key=lambda x: cv2.contourArea(x), reverse=True)
for cnt in contours:
        (x, y, w, h) = cv2.boundingRect(cnt)
        wbuffer = 0.75 * w
        hbuffer = 0.1 * h
        img_meter_ext = img_meter_o[y:y + h + int(hbuffer), x:x + w + int(wbuffer)]
        break
cv2_imshow(img_meter_ext)

"""Convert ROI from BGR to Gray"""

img_meter_ext_gray = cv2.cvtColor(img_meter_ext, cv2.COLOR_BGR2GRAY)
cv2_imshow(img_meter_ext_gray)

"""Apply Gaussian Blur"""

blur = cv2.GaussianBlur(img_meter_ext_gray,(13,13), 0)
cv2_imshow(blur)

"""Apply Erosion"""

erode = cv2.erode(blur, None, iterations=4)
cv2_imshow(erode)

"""Apply Adaptive Thresholding"""

adp_thres = cv2.adaptiveThreshold(erode, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 199, 5)
cv2_imshow(adp_thres)

"""Join Digit Segments by Creating Horizontal & Vertical Structure Element"""

horizontalStructure = cv2.getStructuringElement(cv2.MORPH_RECT, (20, 2))
horizontal = cv2.erode(adp_thres, horizontalStructure)
verticalStructure = cv2.getStructuringElement(cv2.MORPH_RECT, (2, 25))
vertical = cv2.erode(horizontal, verticalStructure)
cv2_imshow(vertical)

"""Apply Dilation"""

dilate = cv2.dilate(vertical, None, iterations=9)
cv2_imshow(dilate)

"""Apply easyocr on rectified meter image"""

easyocr_output=reader.readtext(dilate, allowlist = '0123456789')
easyocr_output

"""Alternatively, pytesseract ocr can be applied to identify digit"""

tesseract_output = pytesseract.image_to_string(dilate)
tesseract_output

"""Computing Final Meter Reading"""

temp = output[1][1]
final_reading= temp[0] + temp[1] + temp[2] + temp[3] + temp[4]+ "." + temp[5]
final_reading

"""Display final meter reading"""

cv2.putText(img_meter_o,final_reading, (500,1000), cv2.FONT_HERSHEY_SIMPLEX, 9, (128,0,0), 2)
cv2_imshow(img_meter_o)